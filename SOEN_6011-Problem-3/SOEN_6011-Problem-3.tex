
\documentclass[letterpaper, 11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{titlesec}
\usepackage{fullpage} % changes the margin
\usepackage{graphicx} %package to manage images
\graphicspath{ {./images/} }
\usepackage{algpseudocode}
\usepackage{algorithm}

\begin{document}
\begin{titlepage}
\vspace*{0.7in}
\begin{center}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=8cm]{univ_logo}
\end{center}
\end{figure}
\vspace*{0.3in}
\begin{Large}
\textbf{SOEN 6011 : SOFTWARE ENGINEERING PROCESSES} \\
\end{Large}
\vspace*{0.1in}
\begin{Large}
\textbf{SUMMER 2021} \\
\end{Large}
\vspace*{0.9in}
\begin{Large}
\textbf{SUPER CALCULATOR} \\
\end{Large}
\vspace*{0.9in}
\begin{Large} 


\textbf{PROBLEM - 3} \\
Pseudo-code and Algorithms\\
\end{Large}
\vspace*{0.625in}
\rule{80mm}{0.1mm}\\
\vspace*{0.1in}
\begin{large}
Authors \\
\vspace*{0.1in}
Rokeya Begum Keya\\
\vspace*{0.1in}
Kyle Taylor Lange\\
\vspace*{0.1in}
Sijie Min\\
\vspace*{0.1in}
Manimaran Palani\\ 
\vspace*{0.3in}
\date{\normalsize\today} 
\end{large}
\end{center}
\begin{center}
https://www.overleaf.com/project/610304de4e6b8d24f7c781b6\end{center}
\end{titlepage}
\tableofcontents
\newpage
\addcontentsline{toc}{section}{a) Decision on Pseudo-Code Format }
\newpage
\section*{Decision on Pseudo-Code Format}
\addcontentsline{toc}{section}{b \& c) Algorithm Description and Pseudo-Code }
Our Team conducted a brainstorming session and referred several resources \cite{standard} \cite{Janos} to decide on Pseudo code algorithm/pattern. As a conclusion, Everyone had agreed to make a pseudo code of their respective algoriths in the Algorithmicx (algpseudocode) \cite{algorithmicx} format available in Overleaf Latex.
\\\\\\
\textbf{Example of Algorithmicx (algpseudocode) Pseudo code Pattern}
\\
\begin{algorithm}
\caption{Algorithmicx (algpseudocode) Pseudo code Pattern}
\begin{algorithmic}
\Require $n \geq 0$
\Ensure $y = x^n$
\State $y \gets 1$
\State $X \gets x$
\State $N \gets n$
\While{$N \neq 0$}
\If{$N$ is even}
    \State $X \gets X \times X$
    \State $N \gets \frac{N}{2}$  \Comment{This is a comment}
\ElsIf{$N$ is odd}
    \State $y \gets y \times X$
    \State $N \gets N - 1$
\EndIf
\EndWhile
\end{algorithmic}
\end{algorithm}

\pagebreak
\section*{Algorithm Description and Pseudo-Code}
\section*{\centering{PROBLEM 3 - F2: $tan(x)$}}
\normalsize {SOEN 6011 - Summer 2021} \hfill \textbf{Rokeya Begum Keya} \\
\textbf{ Software Engineering Processes}  \hfill \textbf{40183615} \\
\hfill Repository address : https://github.com/Dakatsu/SOEN6011Calculator
\\\\\\
\textbf{\\ \\ Technical Reasons for selecting Maclaurin Series: }
\begin{itemize}
\item There are many reasons for selecting Maclaurin Series for calculating the value of $tan(x)$ function. Below are some advantages for which I selected Maclaurin Series:
\end{itemize}
\textbf{Advantages: }
\begin{itemize}
\item Maclaurin series provides more approximate values for the tangent function.
\item The formula to calculate the value of $sin(x)$ and $cos(x)$ function to get the value of tangent function is easy to understand.\[tan(x) = \frac{sin(x)}{cos(x)}\]
\end{itemize}
\textbf{Disadvantages: }
\begin{itemize}
\item There is an another form of Maclaurin series to calculate the tangent function. For example: derivation of $tan(x)$ function. In this formula there are no use of $sin(x)$ and $cos(x)$ function. However, using this formula we can not get the approximate value of $tan(x)$ function.
\end{itemize}
\textbf{Therefore, I select the Maclaurin series of $sin(x)$ and $cos(x)$ to calculate the tangent function.}
\\
\textbf{\\ \\ Algorithm 1 - Maclaurin Series: } 
\begin{itemize}
\item In this project to calculate $tan(x)$ function, I select the Maclaurin Series.
Maclaurin series is just a special case of
taylor series where region near $x=0$.
\item The $tan(x)$ function's approximation is derived by the Maclaurin Series's explicit forms of $sin(x)$ and $cos(x)$.
\begin{equation} 
sin(x) = x-x^3/3!+x^5/5!-x^7/7!+.....
\end{equation}
\begin{equation} 
cos(x) = 1-x^2/2!+x^4/4!-x^6/6!+.....
\end{equation}
\item As, $tan(x)$ is an odd function, odd derivatives when x=0 of Maclaurin series are used to calculate $tan(x)$ function. \item The output are in integer and provide an approximate value for tangent function.
\end{itemize}

\textbf{Pseudo Code for Maclaurin Series}
\\\\\\\\\\\\\
\begin{algorithm}
\caption{Maclaurin Series} \label{alg:cap}
\begin{algorithmic}
\Require $retVal = 1$ AND $tmpResult = 1$ AND $i=1$
\Function{Explicit form}{cos(x)}
\For{$i \gets i+2$}
\State $value = (-1)*x*x/(i*(i+1))$\Comment{$Series for cos(x) $}
\State $tmpResult = tmpResult * value$
\If{check($value$)$<=EPS$}
    \EndIf   
    \State $retVal = retVal + tmpResult$ 
\EndFor \\
\Return{$retVal$}\Comment{$get value of cos(x)$}
\EndFunction
\Require $retVal = x$ AND $tmpResult = x$ AND $i=0$
\Function{Explicit form}{sin(x)}
\For{$i \gets i+1$}
\State $value = ((-1)*x*x/((2*i+2)*(2*i+3)))$\Comment{$Series for sin(x) $}
\State $tmpResult = tmpResult * value$
\If{check($value$)$<=EPS$}
    \EndIf   
    \State $retVal = retVal + tmpResult$ 
\EndFor \\
\Return{$retVal$}\Comment{$get value of sin(x)$}
\EndFunction
\Require $x = Rad(x)$ AND $SinVal = retVal$ AND $CosVal= reVal$
\Function{Calculate}{tan(x)}
\If{$SinVal< EPSvalMini$}
\\\ \Return 0
    \EndIf   
\If{$CosVal< EPSvalMini$}
\\\    \Return $undefined$
    \EndIf \\      
\Return{$SinVal$/$CosVal$}\Comment{$calculation for tan(x)$}
\EndFunction
\State $result \gets $\Call{$tan(x)$}{}
\end{algorithmic}
\end{algorithm}
\pagebreak

\section*{\centering{PROBLEM 3 - F3: Hyperbolic Sine, $sinh(x)$}}
\normalsize {SOEN 6011 - Summer 2021} \hfill \textbf{Kyle Taylor Lange} \\
\textbf{ Software Engineering Processes}  \hfill \textbf{27627696} \\
\hfill Repository address : https://github.com/Dakatsu/SOEN6011Calculator
\\\\\\

\normaltext{Exponentiation of integers is simple to implement in an algorithm, with 1 being multiplied or divided by a number ($e$) a certain number of times. Exponentation of non-real integer numbers is much more difficult as both methods considered to calculate them involve calculating roots of numbers. Calculating the root requires repeatedly testing guesses as to whether raising them to the $n^th$ exponent will equal input number, and it can theoretically take infinite iterations to find the root. As such, there must be a balance between the precision of this value and the time spent calculating it. \\\\
One method for calculating real exponents involves the relation of the natural logarithm, $ln$ $x$, with the exponential function, $e^x$. The other attempts to convert irrational real exponents into rational ones, e.g. $e^\frac{a}{b}$, where $x^a$ is divided by $\sqrt[b]{x}$. This latter method was chosen as it is conceptually easier to comprehend and implement in code, and issues with computation time or accuracy can be adjusted by changing how well the rational number approximates the real number. \\\\
Given the above, the subordinate functions required to calculate $sinh(x)$ are the power function and the square root function. Additionally, a function to find the greatest common denominator can help reduce fractions to make them less intensive to compute. An absolute value function can also be created for simplicity.}

\begin{algorithm}
\caption{Hyperbolic Sine}
\begin{algorithmic}
\Function{Sinh}{$input$}
    \If{$input = 0$}
        \Return{0}
    \EndIf
    \State{$intPart \gets input \div 1$, $fracNum \gets input$ $mod$ $1$}\Comment{Split into integral and real parts.}
    \State{$fracDen \gets 1$}
    \While{$fracNum > fracDen$}
        \State{$fracDen \gets fracDen \times 10$}
    \EndWhile \\
    \Call{GCD}{$fracNum$, $fracDen$}
    \State{$left \gets \Call{Power}{e, intPart}$, $right \gets \Call{Power}{e, -intPart}$}
    \If{$fracNum > 0$}
        \State{$numPower \gets \Call{Power}{e, fracNum}$}
        \State{$leftRoot = \Call{Root}{fracDen, numPower}$}
        \State{$left \gets left \times leftRoot$}
        \State{$numCalc \gets \Call{Power}{e, -numPower}$}
        \State{$rightRoot = \Call{Root}{fracDen, numCalc}$}
        \State{$right \gets right \times rightRoot$}
    \EndIf \\
    \Return{$\frac{left - right}{2}$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Root}
\begin{algorithmic}
\Function{Root}{$n$, $base$}
\State{$step \gets 0$}
    \If{$base$ \textless $1$}
        \State{$step$ \gets $\frac{1 - base}{2}$}
    \Else
        \State{$step$ \gets $\frac{base}{2}$ $+$ $0.5$}
    \EndIf
    \State{$result \gets base$}
    \While{$step \neq 0$}\Comment{Not equal $\pm$ some accuracy value.}
        \State{$resultSquared \gets \Call{Power}{result, n}$}
        \If{$resultSquared = base$}
            \State{break}
        \EndIf
        \If{$resultSquared \textless base$}
            \State{$result \gets result + step$}
        \Else
            \State{$result \gets result - step$}
        \EndIf
        \State{$step \gets \frac{step}{2}$}
    \EndWhile \\
    \Return{$result$}
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Power}
\begin{algorithmic}
\Function{Power}{$base$, $exp$}
    \State{$result \gets 1$}
    \For{$i \gets 0$ to $|exp|$}
        \If{$exp > 0$}
            \State{$result \gets result \times base$}
        \Else
            \State{$result \gets \frac{result}{base}$}
        \EndIf \\
    \Return $result$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Greatest Common Denominator}
\begin{algorithmic}
\Require $x$ $\in$ \mathbb{Z} AND $y$ $\in$ \mathbb{Z}
\Function{GCD}{$x$, $y$}
    \If{$|y| > |x|$}
        \Call{GCD}{y, x}
    \EndIf
    \If{$x$ = 0 AND $y$ = 0}
        \Return{0}
    \EndIf
    \For{$i \gets x to 0$}
        \If{$x$ $mod$ $i$ $=$ $0$ AND $y$ $mod$ $i$ $=$ $0$}
            \Return{$i$}
        \EndIf
    \EndFor \\
    \Return{1}
\EndFunction
\end{algorithmic}
\end{algorithm}

\pagebreak



\section*{\centering{PROBLEM 3 - F7 : \(x^y\)}}
\normalsize {SOEN 6011 - Summer 2021} \hfill \textbf{Manimaran Palani} \\
\textbf{ Software Engineering Processes}  \hfill \textbf{40167543} \\
\hfill Repository address : https://github.com/Dakatsu/SOEN6011Calculator
\\
\textbf{\\ \\ Algorithm : Montgomery's Ladder Technique}\cite{Peter} 
\begin{itemize}
\item Montgomerym's ladder technique addresses defence against side-channel attacks for exponentiation computation. \\\\
The algorithm prevents the recovery of the exponent involved in the computation which could possibly benefit an attacker
\item The algorithm performs a fixed sequence of operations (up to log n): a multiplication and squaring takes place for each bit in the exponent, regardless of the bit's specific value.
\end{itemize}
\vspace*{0.2in}
\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ |p{6cm}|p{6cm}| }
\hline
\textbf{Advantages} & \textbf{Disadvantages}
\\ \hline 
It addresses the concern of MIM(Middle Man attack) observing the sequence of squaring and multiplications can (partially) recover the exponent involved in the computation. & Cache timing attacks are not yet protected and memory access latency might still be observable to an attacker\\
\hline
\end{tabular} 

\textbf{\\ \\ Algorithm : Taylor series}\\ \\Taylor series is a representation of a function as an infinite sum of terms that are calculated from the values of the function's derivatives at a single point.
\begin{equation} \label{evalpow}
x^y= e^{y\ln x}
\end{equation}
\ref{evalpow} evaluation of $x^y$. Here, e is a mathematical constant approximately equal to  2.71828
\begin{equation} \label{extaylor}
e^x = 1 + x/1! + x^2/2! + x^3/3! + ...... 
\end{equation}
\ref{extaylor} express $e^x$ using Taylor Series
\begin{equation} \label{altextaylore}
e^x = 1 + (x/1) (1 + (x/2) (1 + (x/3) (........) ) ) 
\end{equation}
\ref{altextaylore} The series \ref{extaylor} can be re-written as above
\begin{equation} \label{logtaylor}
log(1+x) = x-x^2/2 + x^3/3- ... 
\end{equation}
\ref{logtaylor} express ln x using Taylor Series\\ \\

\setlength{\tabcolsep}{18pt}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ |p{6cm}|p{6cm}| }
\hline
\textbf{Advantages} & \textbf{Disadvantages}\\ \hline 
Very useful for derivations
 & Successive terms get very complex and hard to derive\\
\hline
Can be used to get theoretical error bounds &Truncation error tends to grow rapidly away from expansion point\\
\hline
Power series can be inverted to yield the inverse function & Almost always not as efficient as curve fitting or direct approximation\\
\hline
\end{tabular} \\ \\ 
\begin{algorithm}
\caption{Montgomery's ladder Exponential Function}\label{exp3}
\begin{algorithmic}[1]
\Require $x\textsubscript{1} = x$; $x\textsubscript{2} = x^2$
\For{$i=k-2$ to 0 $do$}
\If{$n \textsubscript{i}=0$} 
\State  $x\textsubscript{2}$ = $x\textsubscript{1}$ * $x\textsubscript{2}$ \Comment{\textit{$x\textsubscript{1}$ = $x\textsubscript{1}^2$}}
 \Else:
\State $x\textsubscript{1} = x\textsubscript{1} * x\textsubscript{2}$   \Comment{\textit{$x2 = x\textsubscript{2}^2$}}
\State \Return $x\textsubscript{1}$
 \EndIf
 \EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Exponentiation by Taylor Series}\label{exp1}
\begin{algorithmic}[1]
\Require $x \neq 0$ AND $y > 0$

\Function{logarithm}{$n$}\Comment{$algorithm for log(n)$}
\State $sum\gets 0$
\While{$n > 1$}
    \State $n\gets n/e$\Comment{e is a constant approximately equal to 2.71828}
    \State $y \gets y+1 $
\EndWhile \\
\Return $y$
\EndFunction

\Function{exponential}{$x$}\Comment{$algorithm for e^x$}
\State $sum\gets 1$
\State $n\gets 10$
\For{$i\gets n-1$, 1}
\State $sum\gets 1+ x * sum / i$
\EndFor \\
\Return $sum$
\EndFunction

\State $logx \gets $\Call{logarithm}{x}
\State $result \gets $\Call{exponential}{y*logx}
\end{algorithmic}
\end{algorithm}

\begin{thebibliography}{}
\bibitem{algorithmicx} 
Algorithmicx (algpseudocode)
\\\texttt{https://www.overleaf.com/latex/examples/pseudocode-example/pbssqzhvktkj}
\bibitem{standard} 
Pseudo-Code Standard
\\\texttt{http://users.csc.calpoly.edu/\~jdalbey/SWE/pdl\_std.html}
\bibitem{Janos} 
Szasz Janos, The algorithmicx package
\\\texttt{http://tug.ctan.org/macros/latex/contrib/algorithmicx/algorithmicx.pdf}
\bibitem{Peter} 
 Montgomery, Peter L. (1987). "Speeding the Pollard and Elliptic Curve Methods of Factorization" (PDF)
\\\texttt{https://www.ams.org/journals/mcom/\\1987-48-177/S0025-5718-1987-0866113-7/S0025-5718-1987-0866113-7.pdf}
\end{thebibliography}
\pagebreak

\section*{\centering{PROBLEM 3 - F5}}
\\


\normalsize {SOEN 6011 - Summer 2021} \hfill \textbf{Sijie Min} \\
\textbf{ Software Engineering Processes}  \hfill \textbf{40152234} \\
\hfill Repository address : https://github.com/Dakatsu/SOEN6011Calculator
\\\\\\\\\\

\\\\The difficulty in implementing function 5 is to implement b$^$x.
\\When X is an integer, there are two alternatives. One is direct accumulation. The advantage is that the code is easy to implement, but the disadvantage is that the running efficiency is not high (x times of multiplications are required); the second is to reduce the number of multiplications by decomposing the exponent. The advantage is that it runs more efficiently, but the disadvantage is that the code implementation is more complicated. For function 5, use the second method to achieve.
\\When X is a decimal, use Taylor series, because b\(^\)x=e\(^\)xlnb, Taylor series can calculate ln(x) and e\(^\)x, and can provide high-precision results. The disadvantage is that the function approximation requires a large amount of calculation.
C)
When x is an integer, if x is an even number, b\(^\)x can be decomposed into (b\(^\)2)\(^\)(x/2); if x is an odd number, b\(^\)x can be decomposed into 〖b×(b\(^\) 2)〗\(^\)((x-1)/2). Continue to decompose until the exponent part is 1.
When x is a decimal, it can be calculated according to the following formula
\\When x is a decimal, it can be calculated according to the following formula:
\\(1) ab$^$x=ae$^$xlnb
\\(2) ex = 1 + x/1! + x2/2! + x3/3! + ......	
\\(3) ln(1 + x) = x − x2/2 + x3/3 − ......
\\\\\\
\textbf{ Pseudo code Pattern}
\\
\begin{algorithm}
\caption{Power function whose exponent part is an integer}
\begin{algorithmic}
\Require $retVal=1 And exp=y And tmp=x$

\State $function Explicit FORM(power(x,y))$
\If{exp$< $0}

\State $exp=-exp$
\EndIf

\While{$ exp>0 $}
\If{exp$\%$2==0}
    \State $exp=exp/2$
    \State $tmp=tmp*tmp$  
\Else
    \State $y \gets y \times X$
    \State $retVal=retVal*tmp$
\EndIf
\EndWhile
\If{y$< $0}

\State $retVal=1/retVal$ 
\State $return retVal$

\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Taylor Series}
\begin{algorithmic}
\Require $retVal=1 And tmp=1 And i=1$

\State $function Explicit FORM(ex(x))$
\For{$ i←i+1$}

\State $tmp=tmp*i$
\State $retVal=retVal+power(x,i)/tmp$
\EndFor \\
\Return {retVal}\\
\EndFunction
\Require $retVal=0 And tmp=1 And And i=1 And x∈(0,2]$
\State $function Explicit FORM(lnBase(x))$
\For{$ i←i+1$}

\State $retVal=retVal+tmp*power(x,i)/i$
\State $tmp=-tmp$
\EndFor \\
\Return {retVal}\\
\EndFunction

\Require $retVal=0 And LN2=ln(2)$
\State $function Explicit FORM(ln(x))$

\While{$ x>2 $}

    \State $retVal=retVal+LN2$
    \State $x=x/2$  
\EndWhile
    \State $retVal=retVal+lnBase(x)$\\
\Return {retVal}
\EndFunction
\end{algorithmic}
\end{algorithm}
\end{document}